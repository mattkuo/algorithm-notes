<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Algorithm Notes</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="java/index.html"><strong aria-hidden="true">1.</strong> Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="java/utility-classes.html"><strong aria-hidden="true">1.1.</strong> Utility Classes</a></li><li class="chapter-item expanded "><a href="java/collections.html"><strong aria-hidden="true">1.2.</strong> Collections Library</a></li></ol></li><li class="chapter-item expanded "><a href="data-structures/index.html"><strong aria-hidden="true">2.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-structures/basic-types/index.html"><strong aria-hidden="true">2.1.</strong> Primitive Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-structures/basic-types/bit-manipulation.html"><strong aria-hidden="true">2.1.1.</strong> Bit Manipulation</a></li></ol></li><li class="chapter-item expanded "><a href="data-structures/bst/index.html"><strong aria-hidden="true">2.2.</strong> Binary Search Trees</a></li><li class="chapter-item expanded "><a href="data-structures/graphs/index.html"><strong aria-hidden="true">2.3.</strong> Graphs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-structures/graphs/traversal.html"><strong aria-hidden="true">2.3.1.</strong> Graph Traversal</a></li><li class="chapter-item expanded "><a href="data-structures/graphs/topological-sort.html"><strong aria-hidden="true">2.3.2.</strong> Topological Sort</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="patterns/index.html"><strong aria-hidden="true">3.</strong> Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/sliding-window.html"><strong aria-hidden="true">3.1.</strong> Sliding Window</a></li><li class="chapter-item expanded "><a href="patterns/two-pointers.html"><strong aria-hidden="true">3.2.</strong> Two Pointers</a></li><li class="chapter-item expanded "><a href="patterns/bfs.html"><strong aria-hidden="true">3.3.</strong> BFS</a></li><li class="chapter-item expanded "><a href="patterns/dfs.html"><strong aria-hidden="true">3.4.</strong> DFS</a></li><li class="chapter-item expanded "><a href="patterns/linked-list-reversal.html"><strong aria-hidden="true">3.5.</strong> Linked-List Reversal</a></li><li class="chapter-item expanded "><a href="patterns/dynamic-programming.html"><strong aria-hidden="true">3.6.</strong> Dynamic Programming (Knapsack)</a></li><li class="chapter-item expanded "><a href="patterns/binary-search.html"><strong aria-hidden="true">3.7.</strong> Binary Search</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Algorithm Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="utility-classesfunctions"><a class="header" href="#utility-classesfunctions">Utility Classes/Functions</a></h1>
<p>Common <code>Math</code> functions</p>
<ul>
<li>abs()</li>
<li>ceil()</li>
<li>floor()</li>
<li>min()</li>
<li>max()</li>
<li>pow()</li>
<li>sqrt()</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections-library"><a class="header" href="#collections-library">Collections Library</a></h1>
<h2 id="comparator"><a class="header" href="#comparator">Comparator</a></h2>
<p>Constructors for various data structures that apply sortation to the data allow you to pass in a comparator to compare elements as they are inserted. In addition the <code>Collections.sort()</code> method allows you to apply sortation to any data structure that implements the <code>List</code> interface. Being comfortable with the <code>Comparator</code> syntax is undoubtedly necessary.</p>
<p>The <code>Comparator</code> has one abstract method <code>compare()</code>.</p>
<pre><code class="language-java">int compare(T obj1, T obj2);
</code></pre>
<ul>
<li>Returns -ive integer if first argument &lt; second argument (or first argument comes before second argument in a natural ordering)</li>
<li>Returns 0 if first argument == second argument </li>
<li>Returns +ive if first argument &gt; second argument (or first argument comes after second argument in a natural ordering)</li>
</ul>
<p>Longhand syntax.</p>
<pre><code class="language-java">public class MyObjectComparator implements Comparator&lt;MyObject&gt; {
    @Override
    public int compare(MyObject obj1, MyObject obj2) {
        return Integer.compare(obj1.getValue(), obj2.getValue());
    }
}
</code></pre>
<p>Functional syntax.</p>
<pre><code class="language-java">Comparator myComparator = (a, b) -&gt; Integer.compare(a.getValue(), b.getValue());
</code></pre>
<p>Note: It's a good idea to use <code>Integer.compare()</code> here to prevent overflow.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<h2 id="sizes-of-types"><a class="header" href="#sizes-of-types">Sizes of Types</a></h2>
<p>In Java, sizes of data types are machine independent. A word in the JVM is 32-bits.</p>
<table><thead><tr><th>Data Type</th><th>Bytes</th><th>Bits</th></tr></thead><tbody>
<tr><td>boolean</td><td>-</td><td>1</td></tr>
<tr><td>byte</td><td>1</td><td>8</td></tr>
<tr><td>short</td><td>2</td><td>16</td></tr>
<tr><td>char</td><td>2</td><td>16</td></tr>
<tr><td>int</td><td>4</td><td>32</td></tr>
<tr><td>float (decimal)</td><td>4</td><td>32</td></tr>
<tr><td>long</td><td>8</td><td>64</td></tr>
<tr><td>double (decimal)</td><td>8</td><td>64</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit-manipulation"><a class="header" href="#bit-manipulation">Bit Manipulation</a></h1>
<p>A common problem is computing the number of bits set to 1 in an integer. There are two solutions:</p>
<ol>
<li>Loop starting at the least significant digit of the integer and bitwise-AND the integer with 1. Increment count and shift right by one bit on each iteration. The runtime complexity is <em>O(n)</em> with <em>n</em> being the number of bits in the integer.</li>
</ol>
<pre><code class="language-java">public int countOnes(int integer) {
    int count = 0;
    while (integer &gt; 0) {
        if ((integer &amp; 1) == 1) {
            count++;
        }

        integer = integer &gt;&gt;&gt; 1;
    }
    return count;
}
</code></pre>
<ol start="2">
<li>A less intuitive approach is to use a couple of bit manipulation tricks to isolate out the least significant bit set to 1 of the input integer and XOR this with the input (to remove this bit). Continue doing this while integer isn't 0. The runtime complexity is <em>O(s)</em> where <em>s</em> is the number of 1's in the integer. This trick works even for negative numbers.</li>
</ol>
<p><em>Note: <code>x &amp; (x - 1)</code> also seem to replace lowest bit that is 1 with 0</em></p>
<pre><code class="language-java">public static int countOnes2(int integer) {
    int count = 0;
    while (integer &gt; 0) {
        // Isolate out the rightmost set bit
        int rightMostOne = integer &amp; ~(integer - 1);
        // Remove the bit from the original input
        integer = integer ^ rightMostOne;
        count++;
    }
    return count;
}
</code></pre>
<p>Summary</p>
<ul>
<li>Clear the lowest set bit: <code>x &amp; (x - 1)</code>
<ul>
<li>Intuition: Substracting one from <code>x</code> will turn the lowest bit into a 0</li>
</ul>
</li>
<li>Isolate lowest 1-bit: <code>x &amp; ~(x - 1)</code>
<ul>
<li>Intuition: Following from above, the NOT operator will turn the 0 into a 1 and so the AND operator will end up selecting the lowest 1-bit</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-search-trees"><a class="header" href="#binary-search-trees">Binary Search Trees</a></h1>
<h2 id="java-libraries"><a class="header" href="#java-libraries">Java Libraries</a></h2>
<p>Java has TreeSet and TreeMap which are libraries that are based on the BST. These store the elements in ascending order.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphs"><a class="header" href="#graphs">Graphs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-traversal"><a class="header" href="#graph-traversal">Graph Traversal</a></h1>
<p>Graphs are typically traversed using depth first search or breadth first search. Both these family of algorithms have certain properties that make them more suitable for some problems over the other. In cases where traversal of a whole graph is required, either approach will find the correct solution.</p>
<h2 id="depth-first-search"><a class="header" href="#depth-first-search">Depth First Search</a></h2>
<p>Greedily traverses the depth of a graph/tree before exploring neighboring nodes. It's often implemented as a recursive algorithm. But, it can also be implemented iteratively using a stack.</p>
<h3 id="recursion"><a class="header" href="#recursion">Recursion</a></h3>
<p>Recursion tends to result in a solution that requires less lines of code.</p>
<pre><code class="language-java">public void dfs(Node root) {
    if (root == null) return;

    for (Node child: root.getChildren()) {
        dfs(child);
    }
}
</code></pre>
<p>The shortcoming of using recursion for DFS is that it requires stack space. A graph with a large depth can quickly result in a stack overflow. This can be overcome by converting the solution to use <a href="https://stackoverflow.com/questions/310974/what-is-tail-call-optimization">tail-recursion</a>.</p>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<p>For languages that do not support tail-recursion optimization (e.g. Java, Python), we can use a Stack data structure to iteratively traverse the graph.</p>
<pre><code class="language-java">public void iterativeDFS(Node root) {
    Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
    stack.add(root);

    while (!stack.isEmpty()) {
        Node current = stack.pop();
        // Perform backtracking tasks

        for (Node child: current.getChildren()) {
            // Traverse child
            stack.push(child);
        }
    }
}
</code></pre>
<h2 id="breadth-first-search"><a class="header" href="#breadth-first-search">Breadth First Search</a></h2>
<p>This algorithm traverses its direct children first before any of its children's children. The consequence of this is that it is able to naturally solve shortest-path problems quite easily.</p>
<pre><code class="language-java">public void bfs(Node root) {
    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);

    while (!queue.isEmpty()) {
        Node current = queue.remove();

        for (Node child: current.getChildren()) {
            queue.add(child);
        }
    }
}
</code></pre>
<p>Notice that the algorithm for BFS is almost identical to iterative DFS. The only difference between that it utilizes a queue (FIFO) versus a stack (LIFO).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topological-sort"><a class="header" href="#topological-sort">Topological Sort</a></h1>
<p>Topological sort is commonly used for resolving dependency graphs or job scheduling. The algorithm only works if the graph is <strong>acyclic</strong>. However, it can be applied to find find out whether a graph is acyclic or cyclic.</p>
<p>For example, given the graph below, the topological order for the graph is <code>ABCD</code> or <code>ACBD</code>.</p>
<div><!-- Generated by graphviz version 3.0.0 (20220226.1711)
 --><!-- Pages: 1 --><svg width="188pt" height="98pt"
 viewBox="0.00 0.00 188.00 98.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 94)"><polygon fill="white" stroke="transparent" points="-4,4 -4,-94 184,-94 184,4 -4,4"/><!-- A --><g id="node1" class="node"><title>A</title><ellipse fill="none" stroke="black" cx="18" cy="-45" rx="18" ry="18"/><text text-anchor="middle" x="18" y="-41.3" font-family="Times,serif" font-size="14.00">A</text></g><!-- B --><g id="node2" class="node"><title>B</title><ellipse fill="none" stroke="black" cx="90" cy="-72" rx="18" ry="18"/><text text-anchor="middle" x="90" y="-68.3" font-family="Times,serif" font-size="14.00">B</text></g><!-- A&#45;&gt;B --><g id="edge1" class="edge"><title>A&#45;&gt;B</title><path fill="none" stroke="black" d="M35.24,-51.26C43.63,-54.5 54.07,-58.53 63.5,-62.17"/><polygon fill="black" stroke="black" points="62.26,-65.44 72.85,-65.77 64.78,-58.91 62.26,-65.44"/></g><!-- C --><g id="node3" class="node"><title>C</title><ellipse fill="none" stroke="black" cx="90" cy="-18" rx="18" ry="18"/><text text-anchor="middle" x="90" y="-14.3" font-family="Times,serif" font-size="14.00">C</text></g><!-- A&#45;&gt;C --><g id="edge2" class="edge"><title>A&#45;&gt;C</title><path fill="none" stroke="black" d="M35.24,-38.74C43.63,-35.5 54.07,-31.47 63.5,-27.83"/><polygon fill="black" stroke="black" points="64.78,-31.09 72.85,-24.23 62.26,-24.56 64.78,-31.09"/></g><!-- D --><g id="node4" class="node"><title>D</title><ellipse fill="none" stroke="black" cx="162" cy="-45" rx="18" ry="18"/><text text-anchor="middle" x="162" y="-41.3" font-family="Times,serif" font-size="14.00">D</text></g><!-- B&#45;&gt;D --><g id="edge3" class="edge"><title>B&#45;&gt;D</title><path fill="none" stroke="black" d="M107.24,-65.74C115.63,-62.5 126.07,-58.47 135.5,-54.83"/><polygon fill="black" stroke="black" points="136.78,-58.09 144.85,-51.23 134.26,-51.56 136.78,-58.09"/></g><!-- C&#45;&gt;D --><g id="edge4" class="edge"><title>C&#45;&gt;D</title><path fill="none" stroke="black" d="M107.24,-24.26C115.63,-27.5 126.07,-31.53 135.5,-35.17"/><polygon fill="black" stroke="black" points="134.26,-38.44 144.85,-38.77 136.78,-31.91 134.26,-38.44"/></g></g></svg></div>
<p>The graph below is non-resolvable by topological sort because D has a dependency on A. <a href="data-structures/graphs/topological-sort.html#breadth-first-search-approach-kahns-algorithm">Kahn's algorithm</a> would return an incomplete ordering of nodes (i.e. <code>AB</code>).</p>
<div><!-- Generated by graphviz version 3.0.0 (20220226.1711)
 --><!-- Pages: 1 --><svg width="188pt" height="98pt"
 viewBox="0.00 0.00 188.00 98.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 94)"><polygon fill="white" stroke="transparent" points="-4,4 -4,-94 184,-94 184,4 -4,4"/><!-- A --><g id="node1" class="node"><title>A</title><ellipse fill="none" stroke="black" cx="18" cy="-45" rx="18" ry="18"/><text text-anchor="middle" x="18" y="-41.3" font-family="Times,serif" font-size="14.00">A</text></g><!-- B --><g id="node2" class="node"><title>B</title><ellipse fill="none" stroke="black" cx="90" cy="-72" rx="18" ry="18"/><text text-anchor="middle" x="90" y="-68.3" font-family="Times,serif" font-size="14.00">B</text></g><!-- A&#45;&gt;B --><g id="edge1" class="edge"><title>A&#45;&gt;B</title><path fill="none" stroke="black" d="M35.24,-51.26C43.63,-54.5 54.07,-58.53 63.5,-62.17"/><polygon fill="black" stroke="black" points="62.26,-65.44 72.85,-65.77 64.78,-58.91 62.26,-65.44"/></g><!-- C --><g id="node3" class="node"><title>C</title><ellipse fill="none" stroke="black" cx="90" cy="-18" rx="18" ry="18"/><text text-anchor="middle" x="90" y="-14.3" font-family="Times,serif" font-size="14.00">C</text></g><!-- A&#45;&gt;C --><g id="edge2" class="edge"><title>A&#45;&gt;C</title><path fill="none" stroke="black" d="M35.24,-38.74C43.63,-35.5 54.07,-31.47 63.5,-27.83"/><polygon fill="black" stroke="black" points="64.78,-31.09 72.85,-24.23 62.26,-24.56 64.78,-31.09"/></g><!-- D --><g id="node4" class="node"><title>D</title><ellipse fill="none" stroke="black" cx="162" cy="-18" rx="18" ry="18"/><text text-anchor="middle" x="162" y="-14.3" font-family="Times,serif" font-size="14.00">D</text></g><!-- B&#45;&gt;D --><g id="edge3" class="edge"><title>B&#45;&gt;D</title><path fill="none" stroke="black" d="M104.83,-61.33C114.61,-53.79 127.92,-43.52 139.13,-34.87"/><polygon fill="black" stroke="black" points="141.42,-37.53 147.2,-28.65 137.14,-31.98 141.42,-37.53"/></g><!-- C&#45;&gt;D --><g id="edge4" class="edge"><title>C&#45;&gt;D</title><path fill="none" stroke="black" d="M107.24,-12.2C115.36,-11.29 125.41,-11.03 134.61,-11.43"/><polygon fill="black" stroke="black" points="134.62,-14.95 144.85,-12.21 135.14,-7.97 134.62,-14.95"/></g><!-- D&#45;&gt;C --><g id="edge5" class="edge"><title>D&#45;&gt;C</title><path fill="none" stroke="black" d="M144.85,-23.79C136.74,-24.71 126.7,-24.97 117.49,-24.57"/><polygon fill="black" stroke="black" points="117.47,-21.06 107.24,-23.8 116.95,-28.04 117.47,-21.06"/></g></g></svg></div>
<h2 id="breadth-first-search-approach-kahns-algorithm"><a class="header" href="#breadth-first-search-approach-kahns-algorithm">Breadth First Search Approach (Kahn's Algorithm)</a></h2>
<p>The intuition here is to start at the top of the dependency tree and removing each node. Once the <a href="https://xlinux.nist.gov/dads/HTML/indegree.html">in-degree</a> of a node reaches zero, remove it and add it to the sort order.</p>
<ol>
<li>Compute the in-degree of each node</li>
<li>Add all nodes with zero dependents into a queue</li>
<li>As each node is removed from the queue, append the node to the result list and for each of its children (dependencies):
<ol>
<li>Decrement its ingress count</li>
<li>Add it to the queue if ingress count reaches 0</li>
</ol>
</li>
<li>When the queue is empty, if the number of nodes in the resulting list is less than the number of nodes, the ordering cannot be resolved (the graph is cyclic).</li>
</ol>
<p>If the graph is <strong>cyclic</strong> the algorithm will report an incomplete ordering. It will reach a point where there is at least two nodes that have an in-degree greater than zero. This property is useful for detecting cycles within a graph.</p>
<h2 id="depth-first-search-approach"><a class="header" href="#depth-first-search-approach">Depth First Search Approach</a></h2>
<p>Intuition: Recursively traverse the graph and mark each node as visited. If a node is already visited, skip it. When a leaf is discovered, add nodes to a stack during backtracking. Unlike the BFS approach, the topological ordering is in reverse order because we traverse the bottom of the dependency graph and add it to the ordering.</p>
<ol>
<li>For each node, recursively traverse the graph</li>
<li>Mark each node as visited</li>
<li>During backtracking, add the node onto a stack</li>
<li>Pop each node of the stack for the topological order</li>
</ol>
<p>The shortcoming of this approach is that it doesn't detect cycles in the graph (although you can use DFS with a few modifications to do so).</p>
<h2 id="problems"><a class="header" href="#problems">Problems</a></h2>
<ul>
<li><a href="https://leetcode.com/problems/course-schedule">Course Scheduling</a></li>
<li><a href="https://leetcode.com/problems/alien-dictionary">Alien Dictionary</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<p>This section groups algorithms according to their patterns. It's loosely based on the <a href="https://www.educative.io/courses/grokking-the-coding-interview">Grokking the Coding Interview</a> course on educative.io. </p>
<h2 id="links--resources"><a class="header" href="#links--resources">Links &amp; Resources</a></h2>
<ul>
<li><a href="https://www.educative.io/courses/grokking-the-coding-interview">Grokking the Coding Interview</a></li>
<li><a href="https://gist.github.com/tykurtz/3548a31f673588c05c89f9ca42067bc4">GCI to LC questions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sliding-window"><a class="header" href="#sliding-window">Sliding Window</a></h1>
<p>The sliding window pattern is the description given to a family of greedy algorithms that can be applied to optimally find the min/max property of a continguous slice of an array. The name comes from the fact that the algorithm keeps track of two indices into the input array, <code>tail</code> and <code>head</code>, that respectively form the start end end of a &quot;window&quot;. The algorithm commonly makes use of a loop invariant to decide whether to shrink or expand the size of the window to arrive at a local optima.</p>
<p>This set of algorithms allow a problem to be solved in one pass with a time complexity of O(n).</p>
<h2 id="fixed-size-window"><a class="header" href="#fixed-size-window">Fixed-size Window</a></h2>
<ul>
<li>The size of the window is perserved. When moving the window, both <code>head</code> and <code>tail</code> are incremented simultaneously.</li>
</ul>
<h2 id="elastic-window"><a class="header" href="#elastic-window">Elastic Window</a></h2>
<ul>
<li>Loop through array by incrementing <code>head</code> while perserving loop invariant</li>
<li>When the loop invariant is violated, shrink the array by incrementing <code>tail</code> until loop invariant no longer violated</li>
</ul>
<p>Example Problems:</p>
<ul>
<li><a href="https://leetcode.com/problems/fruit-into-baskets">Fruits into Baskets</a></li>
</ul>
<h2 id="snapping-window"><a class="header" href="#snapping-window">Snapping Window</a></h2>
<p>When the loop invariant no longer holds, the window snaps closed (<code>tail</code> = <code>head</code> although we don't need to keep track of tail if we don't care about window size).</p>
<p>Example Problems:</p>
<ul>
<li><a href="https://leetcode.com/problems/maximum-subarray">Maximum subarray</a></li>
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters">Longest substring with no repeated characters</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-pointers"><a class="header" href="#two-pointers">Two Pointers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breadth-first-search-1"><a class="header" href="#breadth-first-search-1">Breadth First Search</a></h1>
<p>BFS can be implemented by using a queue to traverse nodes in order of nodes that are closest to start point. This naturally finds the shortest path solution from the root node.</p>
<p>See <a href="patterns/../data-structures/graphs/traversal.html">BFS section</a> of graphs traversal for more information.</p>
<h2 id="level-order-traversal"><a class="header" href="#level-order-traversal">Level Order Traversal</a></h2>
<p>A trick to traverse the tree in order is to observe the size of the queue at the start of the while loop and only traverse this number of nodes in the current iteration. If done correctly, the next iteration will only visit the children of the current iteration.</p>
<pre><code class="language-java">public void bfs(Node root) {
    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);

    while (!queue.isEmpty()) {
        int size = queue.size();
        
        for (int i = 0; i &lt; size; i++) {
            Node current = queue.remove();

            for (Node child: current.getChildren()) {
                queue.add(child);
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="depth-first-search-1"><a class="header" href="#depth-first-search-1">Depth First Search</a></h1>
<p>The recursive process for DFS usually results in less code and is more elegant. DFS can also be done utilizing a stack. See the <a href="patterns/../data-structures/graphs/traversal.html">DFS</a> section on the discussion on graphs for more information. Note that the recursive traversal method is analogous to the iterative one. In iterative traversal, the stack data structure emulates the call stack of the recursive solution.</p>
<h2 id="keeping-track-of-the-current-path"><a class="header" href="#keeping-track-of-the-current-path">Keeping Track of the Current Path</a></h2>
<p>A common pattern is to be asked to find the path from root to leaf. This can be done by keeping track of the current path in a list and removing it during backtracking.</p>
<pre><code class="language-java">public List&lt;Node&gt; dfs(Node root, List&lt;Node&gt; path) {
    if (root == null) return;
    path.add(root);

    if (condition) {
        return path;
    }

    for (Node child: root.getChildren()) {
        dfs(child);
    }

    // We're done considering this node. Remove it as we're now backtracking.
    path.remove(path.size() - 1);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linked-list-reversal"><a class="header" href="#linked-list-reversal">Linked List Reversal</a></h1>
<p>The important thing to recognize here is that you'll need to store the pointer to the next item in the list prior to pointing the current pointer to the previous item.</p>
<p>In total, you'll need to keep track of three pointers.</p>
<ol>
<li><code>current</code>: This is the current node in the list that you're processing</li>
<li><code>previous</code>: This is the head of the newly reversed list</li>
<li><code>next</code>: Points to the next item in the list. Without this, when you update <code>current</code> to point to <code>previous</code>, you'll lose reference to the original list.</li>
</ol>
<p>The algorithm will then look like this:</p>
<ol>
<li>For the <code>current</code> node, save its <code>next</code> node in a temp variable</li>
<li>Point the current node's next pointer to the <code>previous</code> item</li>
<li>Update <code>previous</code> pointer to store the <code>current</code> node</li>
<li>Update <code>current</code> to store the <code>next</code> temp variable from step 1</li>
</ol>
<p>Do this until the <code>current</code> node becomes null and then return <code>previous</code>, which is now the head of the new list. </p>
<p>Can think of this as two parts. Steps 1-2 can be thought of &quot;processing steps&quot; where we're actually reversing the list. Steps 3-4 can be thought as &quot;update&quot; steps.</p>
<p><img src="patterns/../assets/linked-list.svg" alt="Linked List Reversal" /></p>
<h2 id="reversing-sub-lists"><a class="header" href="#reversing-sub-lists">Reversing Sub-lists</a></h2>
<p>For reversing a subsection of the list, think of the list as three separate lists. The first untouched portion, the middle reversed portion and the last untouched portion. Apply the algorithm to the mid section and recombine the three sub-lists.</p>
<p>To recombine, you'll need to store the last node in the first section and the first node in the last section.</p>
<p>When arriving at the sublist to reverse, store the last node of the first list (<code>previous</code>) and what will be the last node of the middle list after reversing(<code>current</code>). The diagram below shows why we need to store these as they will be needed when recombining the sublists.</p>
<p><img src="patterns/../assets/linked-list2.svg" alt="Reversing sub-lists of a linked list" /></p>
<p>After reversing, we can recombine the lists by setting <code>lastNode.next = previous</code> and <code>midLastNode.next = current</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic Programming</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-search"><a class="header" href="#binary-search">Binary Search</a></h1>
<p>Binary search can typically be used to find a certain element in a sorted collection (i.e. Array, LinkedList or Matrix). The basic case applies when the exact target element is in the collection.</p>
<p>Apply the following agorithm while <code>start &lt;= end</code>:</p>
<ol>
<li>Split the array in the middle use <code>middle = start + (end - start) / 2</code> to prevent integer overflow</li>
<li>If the target element is smaller than the <code>middle</code> element, apply the algorithm to the left side of the array: <code>end = mid - 1</code></li>
<li>If the target element is grater than the <code>middle</code> element, apply the algorithm to the right side of the array: <code>start = mid + 1</code></li>
<li>If equal, return the element</li>
</ol>
<h2 id="variation-in-loop-invariant"><a class="header" href="#variation-in-loop-invariant">Variation in Loop Invariant</a></h2>
<p>The loop invariant <code>start &lt;= end</code> introduces some interesting properties when the target element isn't in the collection. At the beginning of the last iteration, <code>start == middle == end</code>. So when the algorithm progresses, because of steps 2 or 3 above, the <code>start</code> will become the smallest element greater than the target (ceiling). The <code>end</code> element will become the largest element smaller than the target (floor).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>

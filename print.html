<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interview Notes</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="java/index.html"><strong aria-hidden="true">1.</strong> Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="java/utility-classes.html"><strong aria-hidden="true">1.1.</strong> Utility Classes</a></li><li class="chapter-item expanded "><a href="java/collections.html"><strong aria-hidden="true">1.2.</strong> Collections Library</a></li></ol></li><li class="chapter-item expanded "><a href="data-structures/index.html"><strong aria-hidden="true">2.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-structures/basic-types/index.html"><strong aria-hidden="true">2.1.</strong> Primitive Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-structures/basic-types/bit-manipulation.html"><strong aria-hidden="true">2.1.1.</strong> Bit Manipulation</a></li></ol></li><li class="chapter-item expanded "><a href="data-structures/bst/index.html"><strong aria-hidden="true">2.2.</strong> Binary Search Trees</a></li><li class="chapter-item expanded "><a href="data-structures/graphs/index.html"><strong aria-hidden="true">2.3.</strong> Graphs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-structures/graphs/traversal.html"><strong aria-hidden="true">2.3.1.</strong> Graph Traversal</a></li><li class="chapter-item expanded "><a href="data-structures/graphs/topological-sort.html"><strong aria-hidden="true">2.3.2.</strong> Topological Sort</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="patterns/index.html"><strong aria-hidden="true">3.</strong> Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/sliding-window.html"><strong aria-hidden="true">3.1.</strong> Sliding Window</a></li><li class="chapter-item expanded "><a href="patterns/dynamic-programming.html"><strong aria-hidden="true">3.2.</strong> Dynamic Programming (Knapsack)</a></li><li class="chapter-item expanded "><a href="patterns/two-pointers.html"><strong aria-hidden="true">3.3.</strong> Two Pointers</a></li><li class="chapter-item expanded "><a href="patterns/bfs.html"><strong aria-hidden="true">3.4.</strong> BFS</a></li><li class="chapter-item expanded "><a href="patterns/dfs.html"><strong aria-hidden="true">3.5.</strong> DFS</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Interview Notes</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="utility-classesfunctions"><a class="header" href="#utility-classesfunctions">Utility Classes/Functions</a></h1>
<p>Common <code>Math</code> functions</p>
<ul>
<li>abs()</li>
<li>ceil()</li>
<li>floor()</li>
<li>min()</li>
<li>max()</li>
<li>pow()</li>
<li>sqrt()</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="collections-library"><a class="header" href="#collections-library">Collections Library</a></h1>
<h2 id="comparator"><a class="header" href="#comparator">Comparator</a></h2>
<p>Constructors for various data structures that apply sortation to the data allow you to pass in a comparator to compare elements as they are inserted. In addition the <code>Collections.sort()</code> method allows you to apply sortation to any data structure that implements the <code>List</code> interface. Being comfortable with the <code>Comparator</code> syntax is undoubtedly necessary.</p>
<p>The <code>Comparator</code> has one abstract method <code>compare()</code>.</p>
<pre><code class="language-java">int compare(T obj1, T obj2);
</code></pre>
<ul>
<li>Returns -ive integer if first argument &lt; second argument (or first argument comes before second argument in a natural ordering)</li>
<li>Returns 0 if first argument == second argument </li>
<li>Returns +ive if first argument &gt; second argument (or first argument comes after second argument in a natural ordering)</li>
</ul>
<p>Longhand syntax.</p>
<pre><code class="language-java">public class MyObjectComparator implements Comparator&lt;MyObject&gt; {
    @Override
    public int compare(MyObject obj1, MyObject obj2) {
        return Integer.compare(obj1.getValue(), obj2.getValue());
    }
}
</code></pre>
<p>Functional syntax.</p>
<pre><code class="language-java">Comparator myComparator = (a, b) -&gt; Integer.compare(a.getValue(), b.getValue());
</code></pre>
<p>Note: It's a good idea to use <code>Integer.compare()</code> here to prevent overflow.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<h2 id="sizes-of-types"><a class="header" href="#sizes-of-types">Sizes of Types</a></h2>
<p>In Java, sizes of data types are machine independent. A word in the JVM is 32-bits.</p>
<table><thead><tr><th>Data Type</th><th>Bytes</th><th>Bits</th></tr></thead><tbody>
<tr><td>boolean</td><td>-</td><td>1</td></tr>
<tr><td>byte</td><td>1</td><td>8</td></tr>
<tr><td>short</td><td>2</td><td>16</td></tr>
<tr><td>char</td><td>2</td><td>16</td></tr>
<tr><td>int</td><td>4</td><td>32</td></tr>
<tr><td>float (decimal)</td><td>4</td><td>32</td></tr>
<tr><td>long</td><td>8</td><td>64</td></tr>
<tr><td>double (decimal)</td><td>8</td><td>64</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="bit-manipulation"><a class="header" href="#bit-manipulation">Bit Manipulation</a></h1>
<p>A common problem is computing the number of bits set to 1 in an integer. There are two solutions:</p>
<ol>
<li>Loop starting at the least significant digit of the integer and bitwise-AND the integer with 1. Increment count and shift right by one bit on each iteration. The runtime complexity is <em>O(n)</em> with <em>n</em> being the number of bits in the integer.</li>
</ol>
<pre><code class="language-java">public int countOnes(int integer) {
    int count = 0;
    while (integer &gt; 0) {
        if ((integer &amp; 1) == 1) {
            count++;
        }

        integer = integer &gt;&gt;&gt; 1;
    }
    return count;
}
</code></pre>
<ol start="2">
<li>A less intuitive approach is to use a couple of bit manipulation tricks to isolate out the least significant bit set to 1 of the input integer and XOR this with the input (to remove this bit). Continue doing this while integer isn't 0. The runtime complexity is <em>O(s)</em> where <em>s</em> is the number of 1's in the integer. This trick works even for negative numbers.</li>
</ol>
<p><em>Note: <code>x &amp; (x - 1)</code> also seem to replace lowest bit that is 1 with 0</em></p>
<pre><code class="language-java">public static int countOnes2(int integer) {
    int count = 0;
    while (integer &gt; 0) {
        // Isolate out the rightmost set bit
        int rightMostOne = integer &amp; ~(integer - 1);
        // Remove the bit from the original input
        integer = integer ^ rightMostOne;
        count++;
    }
    return count;
}
</code></pre>
<p>Summary</p>
<ul>
<li>Clear the lowest set bit: <code>x &amp; (x - 1)</code>
<ul>
<li>Intuition: Substracting one from <code>x</code> will turn the lowest bit into a 0</li>
</ul>
</li>
<li>Isolate lowest 1-bit: <code>x &amp; ~(x - 1)</code>
<ul>
<li>Intuition: Following from above, the NOT operator will turn the 0 into a 1 and so the AND operator will end up selecting the lowest 1-bit</li>
</ul>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="binary-search-trees"><a class="header" href="#binary-search-trees">Binary Search Trees</a></h1>
<h2 id="java-libraries"><a class="header" href="#java-libraries">Java Libraries</a></h2>
<p>Java has TreeSet and TreeMap which are libraries that are based on the BST. These store the elements in ascending order.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="graphs"><a class="header" href="#graphs">Graphs</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="graph-traversal"><a class="header" href="#graph-traversal">Graph Traversal</a></h1>
<p>Graphs are typically traversed using depth first search or breadth first search. Both these family of algorithms have certain properties that make them more suitable for some problems over the other. In cases where traversal of a whole graph is required, either approach will find the correct solution.</p>
<h2 id="depth-first-search"><a class="header" href="#depth-first-search">Depth First Search</a></h2>
<p>Greedily traverses the depth of a graph/tree before exploring neighboring nodes. It's often implemented as a recursive algorithm. But, it can also be implemented iteratively using a stack.</p>
<h3 id="recursion"><a class="header" href="#recursion">Recursion</a></h3>
<p>Recursion tends to result in a solution that requires less lines of code.</p>
<pre><code class="language-java">public void dfs(Node root) {
    if (root == null) return;

    for (Node child: root.getChildren()) {
        dfs(child);
    }
}
</code></pre>
<p>The shortcoming of using recursion for DFS is that it requires stack space. A graph with a large depth can quickly result in a stack overflow. This can be overcome by converting the solution to use <a href="https://stackoverflow.com/questions/310974/what-is-tail-call-optimization">tail-recursion</a>.</p>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<p>For languages that do not support tail-recursion optimization (e.g. Java, Python), we can use a Stack data structure to iteratively traverse the graph.</p>
<pre><code class="language-java">public void iterativeDFS(Node root) {
    Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
    stack.add(root);

    while (!stack.isEmpty()) {
        Node current = stack.pop();
        // Perform backtracking tasks

        for (Node child: current.getChildren()) {
            // Traverse child
            stack.push(child);
        }
    }
}
</code></pre>
<h2 id="breadth-first-search"><a class="header" href="#breadth-first-search">Breadth First Search</a></h2>
<p>This algorithm traverses its direct children first before any of its children's children. The consequence of this is that it is able to naturally solve shortest-path problems quite easily.</p>
<pre><code class="language-java">public void bfs(Node root) {
    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);

    while (!queue.isEmpty()) {
        Node current = queue.remove();

        for (Node child: current.getChildren()) {
            queue.add(child);
        }
    }
}
</code></pre>
<p>Notice that the algorithm for BFS is almost identical to iterative DFS. The only difference between that it utilizes a queue (FIFO) versus a stack (LIFO).</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="topological-sort"><a class="header" href="#topological-sort">Topological Sort</a></h1>
<p>Topological sort is commonly used for resolving dependency graphs or job scheduling. The algorithm only works if the graph is <strong>acyclic</strong>. However, it can be applied to find find out whether a graph is acyclic or cyclic.</p>
<p>For example, given the graph below, the topological order for the graph is <code>ABCD</code> or <code>ACBD</code>.</p>
<p><img src="data-structures/graphs/topological_sort_0.generated.svg" alt="" /></p>
<p>The graph below is non-resolvable by topological sort because D has a dependency on A. <a href="data-structures/graphs/topological-sort.html#breadth-first-search-approach-kahns-algorithm">Kahn's algorithm</a> would return an incomplete ordering of nodes (i.e. <code>AB</code>).</p>
<p><img src="data-structures/graphs/topological_sort_1.generated.svg" alt="" /></p>
<h2 id="breadth-first-search-approach-kahns-algorithm"><a class="header" href="#breadth-first-search-approach-kahns-algorithm">Breadth First Search Approach (Kahn's Algorithm)</a></h2>
<p>The intuition here is to start at the top of the dependency tree and removing each node. Once the <a href="https://xlinux.nist.gov/dads/HTML/indegree.html">in-degree</a> of a node reaches zero, remove it and add it to the sort order.</p>
<ol>
<li>Compute the in-degree of each node</li>
<li>Add all nodes with zero dependents into a queue</li>
<li>As each node is removed from the queue, append the node to the result list and for each of its children (dependencies):
<ol>
<li>Decrement its ingress count</li>
<li>Add it to the queue if ingress count reaches 0</li>
</ol>
</li>
<li>When the queue is empty, if the number of nodes in the resulting list is less than the number of nodes, the ordering cannot be resolved (the graph is cyclic).</li>
</ol>
<p>If the graph is <strong>cyclic</strong> the algorithm will report an incomplete ordering. It will reach a point where there is at least two nodes that have an in-degree greater than zero. This property is useful for detecting cycles within a graph.</p>
<h2 id="depth-first-search-approach"><a class="header" href="#depth-first-search-approach">Depth First Search Approach</a></h2>
<p>Intuition: Recursively traverse the graph and mark each node as visited. If a node is already visited, skip it. When a leaf is discovered, add nodes to a stack during backtracking. Unlike the BFS approach, the topological ordering is in reverse order because we traverse the bottom of the dependency graph and add it to the ordering.</p>
<ol>
<li>For each node, recursively traverse the graph</li>
<li>Mark each node as visited</li>
<li>During backtracking, add the node onto a stack</li>
<li>Pop each node of the stack for the topological order</li>
</ol>
<p>The shortcoming of this approach is that it doesn't detect cycles in the graph (although you can use DFS with a few modifications to do so).</p>
<h2 id="problems"><a class="header" href="#problems">Problems</a></h2>
<ul>
<li><a href="https://leetcode.com/problems/course-schedule">Course Scheduling</a></li>
<li><a href="https://leetcode.com/problems/alien-dictionary">Alien Dictionary</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="sliding-window"><a class="header" href="#sliding-window">Sliding Window</a></h1>
<p>The sliding window pattern is the description given to a family of greedy algorithms that can be applied to optimally find the min/max property of a continguous slice of an array. The name comes from the fact that the algorithm keeps track of two indices into the input array, <code>tail</code> and <code>head</code>, that respectively form the start end end of a &quot;window&quot;. The algorithm commonly makes use of a loop invariant to decide whether to shrink or expand the size of the window to arrive at a local optima.</p>
<p>This set of algorithms allow a problem to be solved in one pass with a time complexity of O(n).</p>
<h2 id="fixed-size-window"><a class="header" href="#fixed-size-window">Fixed-size Window</a></h2>
<ul>
<li>The size of the window is perserved. When moving the window, both <code>head</code> and <code>tail</code> are incremented simultaneously.</li>
</ul>
<h2 id="elastic-window"><a class="header" href="#elastic-window">Elastic Window</a></h2>
<ul>
<li>Loop through array by incrementing <code>head</code> while perserving loop invariant</li>
<li>When the loop invariant is violated, shrink the array by incrementing <code>tail</code> until loop invariant no longer violated</li>
</ul>
<p>Example Problems:</p>
<ul>
<li><a href="https://leetcode.com/problems/fruit-into-baskets">Fruits into Baskets</a></li>
</ul>
<h2 id="snapping-window"><a class="header" href="#snapping-window">Snapping Window</a></h2>
<p>When the loop invariant no longer holds, the window snaps closed (<code>tail</code> = <code>head</code> although we don't need to keep track of tail if we don't care about window size).</p>
<p>Example Problems:</p>
<ul>
<li><a href="https://leetcode.com/problems/maximum-subarray">Maximum subarray</a></li>
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters">Longest substring with no repeated characters</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic Programming</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="two-pointers"><a class="header" href="#two-pointers">Two Pointers</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="breadth-first-search-1"><a class="header" href="#breadth-first-search-1">Breadth First Search</a></h1>
<p>BFS can be implemented by using a queue to traverse nodes in order of nodes that are closest to start point. This naturally finds the shortest path solution from the root node.</p>
<p>See <a href="patterns/../data-structures/graphs/traversal.html">BFS section</a> of graphs traversal for more information.</p>
<h2 id="level-order-traversal"><a class="header" href="#level-order-traversal">Level Order Traversal</a></h2>
<p>A trick to traverse the tree in order is to observe the size of the queue at the start of the while loop and only traverse this number of nodes in the current iteration. If done correctly, the next iteration will only visit the children of the current iteration.</p>
<pre><code class="language-java">public void bfs(Node root) {
    Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);

    while (!queue.isEmpty()) {
        int size = queue.size();
        
        for (int i = 0; i &lt; size; i++) {
            Node current = queue.remove();

            for (Node child: current.getChildren()) {
                queue.add(child);
            }
        }
    }
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="depth-first-search-1"><a class="header" href="#depth-first-search-1">Depth First Search</a></h1>
<p>The recursive process for DFS usually results in less code and is more elegant. DFS can also be done utilizing a stack. See the <a href="patterns/../data-structures/graphs/traversal.html">DFS</a> section on the discussion on graphs for more information. Note that the recursive traversal method is analogous to the iterative one. In iterative traversal, the stack data structure emulates the call stack of the recursive solution.</p>
<h2 id="keeping-track-of-the-current-path"><a class="header" href="#keeping-track-of-the-current-path">Keeping Track of the Current Path</a></h2>
<p>A common pattern is to be asked to find the path from root to leaf. This can be done by keeping track of the current path in a list and removing it during backtracking.</p>
<pre><code class="language-java">public List&lt;Node&gt; dfs(Node root, List&lt;Node&gt; path) {
    if (root == null) return;
    path.add(root);

    if (condition) {
        return path;
    }

    for (Node child: root.getChildren()) {
        dfs(child);
    }

    // We're done considering this node. Remove it as we're now backtracking.
    path.remove(path.size() - 1);
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
